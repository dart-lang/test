// Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';

import 'package:matcher/matcher.dart';

import '../backend/closed_exception.dart';
import '../backend/invoker.dart';
import '../utils.dart';
import 'async_matcher.dart';

/// An exception thrown when a test assertion fails.
class TestFailure {
  final String message;

  TestFailure(this.message);

  String toString() => message;
}

/// The type used for functions that can be used to build up error reports
/// upon failures in [expect].
@Deprecated("Will be removed in 1.0.0.")
typedef String ErrorFormatter(
    actual, Matcher matcher, String reason, Map matchState, bool verbose);

/// Assert that [actual] matches [matcher].
///
/// This is the main assertion function. [reason] is optional and is typically
/// not supplied, as a reason is generated from [matcher]; if [reason]
/// is included it is appended to the reason generated by the matcher.
///
/// [matcher] can be a value in which case it will be wrapped in an
/// [equals] matcher.
///
/// If the assertion fails a [TestFailure] is thrown.
///
/// If [skip] is a String or `true`, the assertion is skipped. The arguments are
/// still evaluated, but [actual] is not verified to match [matcher]. If
/// [actual] is a [Future], the test won't complete until the future emits a
/// value.
///
/// If [skip] is a string, it should explain why the assertion is skipped; this
/// reason will be printed when running the test.
///
/// In some cases extra diagnostic info can be produced on failure (for
/// example, stack traces on mismatched exceptions). To enable these,
/// [verbose] should be specified as `true`.
///
/// Returns a [Future] that completes when the matcher is finished running. For
/// the [completes] and [completion] matchers, as well as [throwsA] and related
/// matchers when they're matched against a [Future], this completes when the
/// matched future completes. For the [prints] matcher, it completes when the
/// future returned by the callback completes. Otherwise, it completes
/// immediately.
Future expect(actual, matcher,
    {String reason,
    skip,
    bool verbose: false,
    @Deprecated("Will be removed in 1.0.0.") ErrorFormatter formatter}) {
  formatter ??= (actual, matcher, reason, matchState, verbose) {
    var mismatchDescription = new StringDescription();
    matcher.describeMismatch(actual, mismatchDescription, matchState, verbose);

    return formatFailure(matcher, actual, mismatchDescription.toString(),
        reason: reason);
  };

  if (Invoker.current == null) {
    throw new StateError("expect() may only be called within a test.");
  }

  if (Invoker.current.closed) throw new ClosedException();

  if (skip != null && skip is! bool && skip is! String) {
    throw new ArgumentError.value(skip, "skip", "must be a bool or a String");
  }

  matcher = wrapMatcher(matcher);
  if (skip != null && skip != false) {
    String message;
    if (skip is String) {
      message = "Skip expect: $skip";
    } else if (reason != null) {
      message = "Skip expect ($reason).";
    } else {
      var description = new StringDescription().addDescriptionOf(matcher);
      message = "Skip expect ($description).";
    }

    Invoker.current.skip(message);
    return new Future.value();
  }

  if (matcher is AsyncMatcher) {
    // Avoid async/await so that expect() throws synchronously when possible.
    var result = matcher.matchAsync(actual);
    expect(result, anyOf([
      equals(null),
      new isInstanceOf<Future>(),
      new isInstanceOf<String>()
    ]), reason: "matchAsync() may only return a String, a Future, or null.");

    if (result is String) {
      fail(formatFailure(matcher, actual, result, reason: reason));
    } else if (result is Future) {
      Invoker.current.addOutstandingCallback();
      return result.then((realResult) {
        if (realResult == null) return;
        fail(formatFailure(matcher, actual, realResult, reason: reason));
      }).whenComplete(() {
        // Always remove this, in case the failure is caught and handled
        // gracefully.
        Invoker.current.removeOutstandingCallback();
      });
    }

    return new Future.value();
  }

  var matchState = {};
  try {
    if (matcher.matches(actual, matchState)) return new Future.value();
  } catch (e, trace) {
    reason ??= '$e at $trace';
  }
  fail(formatter(actual, matcher, reason, matchState, verbose));
  return new Future.value();
}

/// Convenience method for throwing a new [TestFailure] with the provided
/// [message].
void fail(String message) => throw new TestFailure(message);

// The default error formatter.
String formatFailure(Matcher expected, actual, String which, {String reason}) {
  var buffer = new StringBuffer();
  buffer.writeln(indent(prettyPrint(expected),       first: 'Expected: '));
  buffer.writeln(indent(prettyPrint(actual),         first: '  Actual: '));
  if (which.isNotEmpty) buffer.writeln(indent(which, first: '   Which: '));
  if (reason != null) buffer.writeln(reason);
  return buffer.toString();
}
